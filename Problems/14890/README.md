# Problem 14890

## 경사로

### 문제
크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.

오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.

다음과 같은 N=6인 경우 지도를 살펴보자.

이때, 길은 총 2N개가 있으며, 아래와 같다.

길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.

경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
아래와 같은 경우에는 경사로를 놓을 수 없다.

경사로를 놓은 곳에 또 경사로를 놓는 경우
낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
경사로를 놓다가 범위를 벗어나는 경우
L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.

경사로를 놓을 수 없는 경우는 아래와 같다.

위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.

가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.

지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.

### 문제 링크
<https://www.acmicpc.net/problem/14890>

### 예제 입력 1
6 2
3 3 3 3 3 3
2 3 3 3 3 3
2 2 2 3 2 3
1 1 1 2 2 2
1 1 1 3 3 1
1 1 2 3 3 2

### 예제 출력 1
3

### 예제 입력 2
6 2
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

### 예제 출력 2
7

### 예제 입력 3
6 3
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

### 예제 출력 3
3

### 예제 입력 4
6 1
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

### 예제 출력 4
11

### solve
- check_row, check_col 배열에 행, 열 별로 지나갈 수 있는 길인지 여부를 저장한다.
	- 초기값을 true로 지정하여 불가능한 경우가 나오면 false로 변경하고 다음 길을 확인하는 방식으로 구현하였다.
- 높이의 차가 2 이상인 경우는 불가능한 경우이므로 제외시킨다.
- 다음 좌표와의 높이 차를 구해 같은 높이인 경우, 높이가 낮아지는 경우, 높아지는 경우를 각각 처리했다.
- cnt에 같은 높이로 이어지는 블록의 수를 기록하여 경사로의 길이와 비교 후 경사로를 놓을 수 있는지 판별하였다.
	- 이 때, 내려가는 경사로인 경우에는 높이가 낮아진 이후 같은 높이의 블록 수를 계산해야 하므로 check_d라는 변수에 내려가는 경사로를 거친 상태라면 true로 두어 판별하였다.
- 경사로의 길이가 1로 입력된 경우 예외가 많아서 처리하기 힘들었다.
- 1인 경우의 예외는 코드에 주석으로 설명을 해두었다.


### 코드 설명
```C++
#include<iostream>
#include<queue>
#include<algorithm>
#include<vector>
#include<string>
#include<cstring>
#include<climits>

using namespace std;
const int MAX = 100;
int n, l;
int a[MAX][MAX];
bool check_row[MAX];
bool check_col[MAX];

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> l;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			cin >> a[i][j];

	for (int i = 0; i < n; i++)
	{
		int cnt = 1; // 평지의 수
		check_row[i] = true; // 초기값 true (지나갈 수 있는 상태)
		bool check_d = false; // 내려가는 경사로를 거친 상태라면 true

		for (int j = 0; j < n - 1; j++)
		{
			int gap = a[i][j + 1] - a[i][j];
			if (gap > 1 || gap < -1) // 높이차가 2 이상이면 불가능한 경우
			{
				check_row[i] = false;
				break;
			}
			if (gap == 0) // 같은 높이인 경우
			{
				cnt++; // 같은 높이의 개수
				if (l != 1 && check_d && cnt >= l) // 내려가는 경사로를 놓을 수 있는 경우
				{  // 경사로의 길이가 1인 경우는 예외
					check_d = false; // 평지로 인식
					cnt = 0;
				}
			}
			else if (gap == 1) // 높이가 높아진 경우
			{
				if (l != 1 && check_d) // 경사로가 내려가다가 바로 올라가는 경우 불가능
				{
					check_row[i] = false;
					break;
				}
				if (l == 1 && check_d && cnt == 1)
				{  // 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능
					check_row[i] = false;
					break;
				} // l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우
				else if(l == 1 && check_d && cnt > 1) check_d = false;

				if (cnt < l) // 올라가는 경사로를 놓을 수 없는 경우 불가능
				{
					check_row[i] = false;
					break;
				}
				cnt = 1; // 높이가 바뀌었으므로 초기화
			}
			else if (gap == -1) // 높이가 낮아졌다면
			{
				if (l != 1 && check_d) // 연속으로 내려가는 경사로를 두 번 놓을 수 없음
				{ // 1은 예외
					check_row[i] = false;
					break;
				}
				check_d = true; // 다음 높이에서 경사로의 길이를 체크
				cnt = 1;
			}

			if (l != 1 && j == n - 2 && check_d) check_row[i] = false; // 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우
		}
	}


	for (int j = 0; j < n; j++)
	{
		int cnt = 1; // 평지의 수
		check_col[j] = true; // 초기값 true (지나갈 수 있는 상태)
		bool check_d = false; // 내려가는 경사로를 거친 상태라면 true

		for (int i = 0; i < n - 1; i++)
		{
			int gap = a[i + 1][j] - a[i][j];
			if (gap > 1 || gap < -1) // 높이차가 2 이상이면 불가능한 경우
			{
				check_col[j] = false;
				break;
			}
			if (gap == 0) // 같은 높이인 경우
			{
				cnt++; // 같은 높이의 개수
				if (l != 1 && check_d && cnt >= l)  // 내려가는 경사로를 놓을 수 있는 경우
				{ // 경사로의 길이가 1인 경우는 예외
					check_d = false; // 다시 평지로 인식
					cnt = 0;
				}
			}
			else if (gap == 1) // 높이가 높아진 경우
			{
				if (l != 1 && check_d)  // 경사로가 내려가다가 바로 올라가는 경우 불가능
				{
					check_col[j] = false;
					break;
				}
				if (l == 1 && check_d && cnt == 1)
				{ // 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능
					check_col[j] = false;
					break;
				} //l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우
				else if (l == 1 && check_d && cnt > 1) check_d = false;

				if (cnt < l) // 올라가는 경사로를 놓을 수 없는 경우 불가능
				{
					check_col[j] = false;
					break;
				}
				cnt = 1; // 높이가 바뀌었으므로 초기화
			}
			else if (gap == -1) // 높이가 낮아졌다면
			{
				if (l != 1 && check_d) // 연속으로 내려가는 경사로를 두 번 놓을 수 없음
				{ // 1은 예외
					check_col[j] = false;
					break;
				}
				check_d = true; // 다음 높이에서 경사로의 길이를 체크
				cnt = 1;
			}

			if (l != 1 && i == n - 2 && check_d) check_col[j] = false; // 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우
		}
	}

	int ans = 0;
	for (int i = 0; i < n; i++) // 각 행, 열 별로 지나갈 수 있는 길의 수 체크
	{
		if (check_row[i])
		{
			ans++;
			//cout << "row : " << i << '\n'; // 디버깅용
		}
		if (check_col[i])
		{
			ans++;
			//cout << "col : " << i << '\n'; // 디버깅용
		}
	}

	cout << ans << '\n';
}

```
