# Problem 15990

## 1, 2, 3 더하기 5

### 문제
정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

- 1+2+1
- 1+3
- 3+1
정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

### 출력
각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

### 문제 링크
<https://www.acmicpc.net/problem/15990>

### 예제 입력 1
3
4
7
10

### 예제 출력 1
3
9
27

### solve
- 같은 수를 두 번 이상 연속해서 사용하면 안된다.
	- (연속, 증가, 감소) 등의 조건이 나오면 두 개씩 나누어 풀이한다.
- d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j
	- d[i][1] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1
		- 바로 전에 사용할 수 있는 수는 2, 3 => d[i - 1][2] + d[i - 1][3]
	- d[i][2] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2
		- 바로 전에 사용할 수 있는 수는 2, 3 => d[i - 2][1] + d[i - 2][3]
	- d[i][3] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3
		- 바로 전에 사용할 수 있는 수는 2, 3 => d[i - 3][1] + d[i - 3][2]
- d[0] = 1 처럼 d[0][1], d[0][2], d[0][3]을 1로 초기화하면 중복이 발생
	- d[1][1] = d[0][2] + d[0][3] = 2 (1로 끝나는데 1을 만드는 경우는 1뿐)
	- 예외 처리를 해주어야 함.

### 코드 설명
```C++

#include<iostream>

using namespace std;
long long d[100001][4]; // d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j
const long long mod = 1000000009;
int sum123_bottom_up(int);
int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	int t;
	cin >> t;

	while (t--)
	{
		int n;
		cin >> n;
		cout << sum123_bottom_up(n) << '\n';
	}
}

int sum123_bottom_up(int n)
{
	for (int i = 1; i <= n; i++)
	{
		if (i - 1 >= 0)
		{
			d[i][1] = d[i - 1][2] + d[i - 1][3];
			if (i == 1)
				d[i][1] = 1; // 1로 끝나는데 1을 만드는 경우는 1뿐
		}
		if (i - 2 >= 0)
		{
			d[i][2] = d[i - 2][1] + d[i - 2][3];
			if (i == 2)
				d[i][2] = 1;  // 2로 끝나는데 2을 만드는 경우는 2뿐
		}
		if (i - 3 >= 0)
		{
			d[i][3] = d[i - 3][1] + d[i - 3][2];
			if (i == 3)
				d[i][3] = 1; // 3으로 끝나는데 3을 만드는 경우는 3뿐
		}
		d[i][1] %= mod; // 정수 범위를 초과하기
		d[i][2] %= mod;
		d[i][3] %= mod;
	}
	return (d[n][1] + d[n][2] + d[n][3]) % mod;
}

```
