# Problem 15683

## 감시

### 문제
스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.


1번	2번	3번	4번	5번
1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```
지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다.
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 # 6 0
0 0 0 0 0 0
```
```
0 0 0 0 0 0
0 0 0 0 0 0
# # 1 0 6 0
0 0 0 0 0 0
```
```
0 0 # 0 0 0
0 0 # 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 # 0 0 0
```
→	←	↑	↓
CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 벽을 감시할 수 없다.
```
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5
```
위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.
```
0 0 0 0 0 #
# 2 # # # #
0 0 0 0 6 #
0 6 # # 2 #
0 0 0 0 0 #
# # # # # 5
```
```
0 0 0 0 0 #
# 2 # # # #
0 0 0 0 6 #
0 6 0 0 2 #
0 0 0 0 # #
# # # # # 5
```
```
0 # 0 0 0 #
0 2 0 0 0 #
0 # 0 0 6 #
0 6 # # 2 #
0 0 0 0 0 #
# # # # # 5
```
```
0 # 0 0 0 #
0 2 0 0 0 #
0 # 0 0 6 #
0 6 0 0 2 #
0 0 0 0 # #
# # # # # 5
```
왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔	왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕	왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔	왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕
CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.
```
0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
```
위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.
```
# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
```
사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.
### 입력
첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.

CCTV의 최대 개수는 8개를 넘지 않는다.

### 출력
첫째 줄에 사각 지대의 최소 크기를 출력한다.

### 문제 링크
<https://www.acmicpc.net/problem/15683>

### 예제 입력 1
4 6
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0

### 예제 출력 1
20

### 예제 입력 2
6 6
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5

### 예제 출력 2
15

### 예제 입력 3
6 6
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0
0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1

### 예제 출력 3
6

### 예제 입력 4
6 6
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 5 0 0
0 0 5 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
### 예제 출력 4
2

### 예제 입력 5
1 7
0 1 2 3 4 5 6

### 예제 출력 5
0

### 예제 입력 6
3 7
4 0 0 0 0 0 0
0 0 0 2 0 0 0
0 0 0 0 0 0 4
### 예제 출력 6
0

### solve
- 부르트 포스 문제로 모든 경우를 다 확인해 최솟값을 구하면 된다.
- 나는 see라는 함수를 만들어서 현재 좌표에서 현재 방향으로 감시가능한 구역 체크하도록 했다.
  - 인자로 좌표, 방향, flag, num 을 받는다.
  - flag는 1인 경우 감시 구역을 체크하고 아니라면 체크된 감시 구역을 해제한다.
  - 여기서 감시구역을 num으로 체크하는데, num은 7부터 감시카메라의 개수만큼 증가한다.
  - 이렇게 num을 준 이유는 1~6번은 사용중이고, 다른 감시카메라와의 중복 감시구역을 파악하기 위해서다.
  - flag가 1이 아니라면, 현재 방향의 num으로 체크된 구역만 0으로 바꾸어 체크를 해제한다.
- 이후 재귀함수로 입력받은 감시카메라의 개수만큼, 각 감시카메라의 종류가 볼 수 있는 방향을 모두 체크한다.
- 모든 감시카메라 확인 후 0인 구역의 개수가 사각지대의 개수이다. 이것의 최솟값을 구한다.
---
- 3번 감시카메라를 착각해서 감시 방향을 3번만 확인하면 된다고 생각하여 이것을 찾아내는데 시간을 많이 썻다.
- 3번 감시카메라도 네 방향을 모두 보아야 한다.

### 코드 설명
```C++
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<string>
#include<cstring>

using namespace std;
const int MAX = 8;
int n, m;
int a[MAX][MAX];
bool check[MAX];
int dx[] = { 0, 1, 0, -1 };
int dy[] = { 1, 0, -1, 0 };
vector<pair <pair<int, int>, int>> v;
int ans = 100;

void see(int x, int y, int dir, int flag, int num) // 현재 좌표에서 현재 방향으로 감시가능한 구역 체크
{
	if (flag == 1) // 감시 구역 체크
	{
		for (int i = 1; i < max(n, m); i++) // 현재 방향으로 벽이 아닌 모든 구역 확인
		{
			int nx = x + dx[dir] * i;
			int ny = y + dy[dir] * i;
			if (nx >= 0 && ny >= 0 && nx < n && ny < m)
			{
				if (a[nx][ny] == 6) break;
				if (a[nx][ny] == 0) a[nx][ny] = num; // 0인 경우 인자로 받은 num으로 넣어서 구분
			}
		}
	}
	else // 감시 구역 해제
	{
		for (int i = 1; i < max(n, m); i++)
		{
			int nx = x + dx[dir] * i;
			int ny = y + dy[dir] * i;
			if (nx >= 0 && ny >= 0 && nx < n && ny < m)
			{
				if (a[nx][ny] == 6) break;
				if(a[nx][ny] == num) a[nx][ny] = 0; // num 체크 해제
			}
		}
	}
}

void print() // 확인용 출력 함수
{
	cout << '\n';
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
			cout << a[i][j] << ' ';
		cout << '\n';
	}
	cout << '\n';
}

void go(int index, int size)
{
	if (index == size) // 모든 감시카메라 확인 후
	{
		int cnt = 0;
		for(int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
			{
				if (a[i][j] == 0)
					cnt++;
			}

		if (cnt < ans) ans = cnt;
		return;
	}

	int x = v[index].first.first;
	int y = v[index].first.second;
	int type = v[index].second;
	int num = index + 7; // 1~6은 사용중

	if (type == 1) // 1번 경우 네 방향 확인
	{
		for (int k = 0; k < 4; k++)
		{
			see(x, y, k, 1, num); // 감시구역 체크
			go(index + 1, size);
			see(x, y, k, 0, num); // 체크 해제
		}
	}
	else if (type == 2) // 2번 경우 양 방향 확인
	{
		for (int k = 0; k < 2; k++)
		{
			see(x, y, k, 1, num); // 현재 방향 체크
			see(x, y, k + 2, 1, num); // 한칸 건너 뛰고 반대방향 체크
			go(index + 1, size);
			see(x, y, k, 0, num);
			see(x, y, k + 2, 0, num);
		}
	}
	else if (type == 3) // 3번 경우 직각 방향 확인
	{
		for (int k = 0; k < 4; k++)
		{
			see(x, y, k, 1, num); // 현재 방향 체크
			see(x, y, k + 1 > 3 ? 0 : k + 1, 1, num); // 현재 방향과 직각을 이루는 방향 확인
			go(index + 1, size);
			see(x, y, k, 0, num);
			see(x, y, k + 1 > 3 ? 0 : k + 1, 0, num);

		}
	}
	else if (type == 4) // 4번 경우 세 방향 확인
	{
		for (int k = 0; k < 4; k++)
		{
			for (int l = 0; l < 4; l++)
			{
				if (l == k) continue; // 현재 방향 빼고 나머지 세 방향 확인
				see(x, y, l, 1, num);
			}
			go(index + 1, size);
			for (int l = 0; l < 4; l++)
			{
				if (l == k) continue;
				see(x, y, l, 0, num);
			}
		}
	}
	else if (type == 5) // 5번 경우 전 방향 확인
	{
		for (int k = 0; k < 4; k++)
			see(x, y, k, 1, num);

		go(index + 1, size);

		for (int k = 0; k < 4; k++)
			see(x, y, k, 0, num);
	}

}

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
		{
			cin >> a[i][j];
			if (a[i][j] >= 1 && a[i][j] <= 5)
			{ // 감시카메라의 위치 , 종류 저장
				v.push_back(make_pair(make_pair(i, j), a[i][j]));
			}
		}

	go(0, v.size());

	cout << ans << '\n';
}

```
