# Problem 1774

## 수 묶기

### 문제
길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.

예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.

수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.

수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.

### 입력
첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작다. 둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.

### 출력
수를 적절히 묶어 그 합이 최댓값을 출력한다. 정답은 항상 2^31보다 작다.

### 문제 링크
<https://www.acmicpc.net/problem/1774>

### 예제 입력 1
4
-1
2
1
3

### 예제 출력 1
6

### solve
- 그리디로 우선순위 큐를 사용하여 해결하였다.
- 두 수를 곱하여 묶을 수 있으므로 가장 큰 수끼리 먼저 묶는 것이 항상 최댓값이 된다.
- 음수와 양수를 담을 우선순위 큐를 각각 사용하여 양수는 최대 힙으로, 음수는 최소 힙으로 구현한다.
	- 절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있으므로 음수는 최소 힙으로 구현하였고
	- 음수 중 절댓값이 가장 작은 수가 남은 경우 0과 곱하면 더 크게 만들 수 있으므로 0도 음수 큐에 포함시킨다.
- 각각 큐에서 두 개씩 뽑아 곱한 값이 더한 값보다 크다면 곱한 값을 누적하고 아니라면 더한 값을 누적하여 답을 구한다.

### 코드 설명
```C++
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
#include<string>
#include<utility>

using namespace std;

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin >> n;

	priority_queue<int> pq; // 양수를 담을 우선순위 큐
	priority_queue<int, vector<int>, greater<int>> mq; // 음수를 담을 우선순위 큐

	for (int i = 0; i < n; i++) // 양수와 음수를 구분하여 우선순위 큐에 담음 0은 음수에 포함
	{
		int m;
		cin >> m;
		if (m > 0)
			pq.push(m);
		else
			mq.push(m);
	}

	int ans = 0;

	while (pq.size() > 1) // 양수 큐에서
	{
		int x = pq.top();
		pq.pop();
		int y = pq.top();
		pq.pop();

		if (x * y >= x + y) // 큰 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면
			ans += x * y; // 곱한 값 누적
		else
			ans += x + y;
	}
	if (!pq.empty()) // 양수 큐의 수가 홀수 개라면
	{
		int r = pq.top(); // 남은 수 처리
		pq.pop();
		ans += r;
	}

	while (mq.size() > 1) // 음수 큐에서
	{
		int x = mq.top();
		mq.pop();
		int y = mq.top();
		mq.pop();
		 // 절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있음
		if (x * y >= x + y) // 작은 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면
			ans += x * y; // 곱한 값 누적
		else
			ans += x + y;
	}
	if (!mq.empty()) // 음수 큐의 원소가 홀수 개라면
	{
		int r = mq.top(); // 남은 수 처리
		mq.pop();
		ans += r;
	}

	cout << ans << '\n';
}

```
