# Problem 14226

## 이모티콘

### 문제
영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다.

영선이는 이미 화면에 이모티콘 1개를 입력했다. 이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.

화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
화면에 있는 이모티콘 중 하나를 삭제한다.
모든 연산은 1초가 걸린다. 또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다. 클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다. 또한, 클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다. 화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.

영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.

### 출력
첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.

### 문제 링크
<https://www.acmicpc.net/problem/14226>

### 예제 입력 1
2

### 예제 출력 1
2

### 예제 입력 2
4

### 예제 출력 2
4

### 예제 입력 3
6

### 예제 출력 3
5

### 예제 입력 4
18

### 예제 출력 4
8

### solve
1. 화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
2. 클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
3. 화면에 있는 이모티콘 중 하나를 삭제한다.

- 주어진 조건에 따라 bfs를 수행하면 된다.
- 처음에는 문제를 잘 이해하지 못했었다. 화면에 있는 모든 이모티콘을 클립보드에 저장하고 붙여넣기를 하는 연산을 2초짜리 하나의 연산으로 생각하고 문제를 풀었다.
- 하지만 그게 아니라 새로 이모티콘을 복사하지 않고 이전에 클립보드에 저장해둔 이모티콘을 붙여넣는 경우도 있다는 것을 깨달았다.
- d라는 2중 배열을 사용하여 이모티콘의 수 s와 클립보드에 저장된 이모티콘의 개수 c를 저장하였다.
- 초기값을 d[1][0] = 0 으로 설정하고 큐에 pair(1, 0)을 시작 노드로 하여 bfs를 수행한다.
- d는 모두 -1로 초기화를 하였으므로 아직 방문하지 않은 노드에는 -1이 저장되어 있다.
1. 먼저 복사하는 경우, 클립보드에 s를 복사해야 하므로 d[s][s]가 -1인 경우 수행하며 d[s][s]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s, s)를 큐에 push한다.
2. 클립보드에 있는 이모티콘을 붙여넣기 하는 경우, s + c <= n 이고 d[s + c][c]가 -1인 경우 수행하며 d[s + c][c]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s + c, c)를 큐에 push한다.
3. 화면에 있는 이모티콘 하나를 삭제하는 경우, s - 1 >= 0 이고 이고 d[s - 1][c]가 -1인 경우 수행하며 d[s - 1][c]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s - 1, c)를 큐에 push한다.
- 이후 d[n][i]의 -1이 아닌 최솟값을 구하면 된다.

### 코드 설명
```C++
#include<iostream>
#include<queue>
#include<algorithm>
#include<vector>
#include<stack>
#include<cstring>

using namespace std;
const int MAX = 1000;
int d[MAX + 1][MAX + 1]; // d[s][clipboard]의 상태에 되기 까지 걸리는 시간(초)

int main(void)
{
	int n;
	cin >> n; // 만들어야 할 이모티콘 수

	memset(d, -1, sizeof(d)); // -1로 초기화 : -1은 방문하기 전

	queue<pair<int, int>> q; // s, clipboard
	q.push(make_pair(1, 0));
	d[1][0] = 0; // 초기값, 이모티콘 수는 1, 클립보드에는 0개, 걸리는 시간 0초

	while (!q.empty())
	{
		int s = q.front().first;
		int c = q.front().second;
		q.pop();

		if (d[s][s] == -1) // 복사하는 경우, 클립보드에 s를 복사한다.
		{ // 이모티콘 수가 s개이고 클립보드에 s개가 있는경우를 탐색하지 않았다면
			q.push(make_pair(s, s));
			d[s][s] = d[s][c] + 1; // 이전 상태에서 1초를 추가
		}

		if (s + c <= n && d[s + c][c] == -1) // 붙여넣기를 하는 경우
		{
			q.push(make_pair(s + c, c)); // 화면에 c개의 이모티콘이 추가됨
			d[s + c][c] = d[s][c] + 1;
		}

		if (s - 1 >= 0 && d[s - 1][c] == -1) // 이모티콘 하나를 삭제하는 경우
		{
			q.push(make_pair(s - 1, c));
			d[s - 1][c] = d[s][c] + 1;
		}

	}

	int ans = -1;
	for (int i = 0; i <= n; i++)
	{
		if (d[n][i] != -1) // -1이 아닌 최솟값을 구한다.
		{
			if (ans == -1 || ans > d[n][i])
				ans = d[n][i];
		}
	}


	cout << ans << '\n';

}

```
