# Problem 1992

## 쿼드트리

### 문제
흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.

주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다

위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 "(0(0011)(0(0111)01)1)"로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.


### 입력
첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1≤N ≤64의 범위를 가진다. 두 번째 줄부터는 길이 N 의 문자열이 N 개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.

### 출력
영상을 압축한 결과를 출력한다.

### 문제 링크
<https://www.acmicpc.net/problem/1992>

### 예제 입력 1
8
11110000
11110000
00011100
00011100
11110000
11110000
11110011
11110011

### 예제 출력 1
((110(0101))(0010)1(0001))

### solve
- 재귀함수로 분할정복을 통해 해결하였다.
- 현재 크기의 영상이 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적하고 리턴한다.
- 아니라면 4분할하여 재귀를 수행한다.

### 코드 설명
```C++
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
#include<string>

using namespace std;
int a[100][100];
string ans = "";

bool check(int x, int y, int n) // 크기가 n * n인 영상을 확인하는 함수
{
	for(int i = x; i < x + n; i++)
		for (int j = y; j < y + n; j++)
		{
			if (a[x][y] != a[i][j])
				return false;
		}
	return true;
}

void go(int x, int y, int n)
{
	if (check(x, y, n)) // 현재 크기의 영상 확인
	{
		ans += a[x][y]; // 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적
		return;
	}
	else
	{
		ans += '('; // 단계에서 괄호 시작
		int m = n / 2;
		for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
			{
				go(x + m * i, y + m * j, m); // 4분할 하여 재귀
			}
		ans += ')';
	}
}

int main(void)
{
	int n;
	cin >> n;
	cin.ignore();

	for (int i = 0; i < n; i++)
	{
		string str;
		cin >> str;
		for (int j = 0; j < str.size(); j++)
			a[i][j] = str[j];
	}

	go(0, 0, n);
	cout << ans << '\n';
}

```
